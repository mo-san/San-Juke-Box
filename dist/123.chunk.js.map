{"version":3,"file":"123.chunk.js","mappings":"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","sources":["webpack://san-juke-box/./src/components/LetterPainter.ts","webpack://san-juke-box/./src/components/Stage.ts","webpack://san-juke-box/./src/components/ThreeBase.ts","webpack://san-juke-box/./src/components-react/CanvasBase.tsx","webpack://san-juke-box/./src/components-react/CanvasStage.tsx"],"sourcesContent":["import * as THREE from \"three\";\nimport gsap, { Cubic, Expo } from \"gsap\";\nimport MotionPathPlugin from \"gsap/dist/MotionPathPlugin\";\nimport { googleFontNames } from \"../@types/types\";\nimport { useStore } from \"./Store\";\n\ngsap.registerPlugin(MotionPathPlugin);\n\n/**\n * 文字たちが絵や別の文字を構成するエフェクト\n */\nclass LetterPainter {\n  public movingParticles = new THREE.Object3D();\n\n  protected particlesList: THREE.Mesh<THREE.PlaneBufferGeometry, THREE.MeshLambertMaterial>[] = [];\n\n  /**\n   * 背景となる、画像へのURL(同一オリジン)や文字列。\n   * index.html からの相対パス。\n   */\n  protected silhouette = \"img/logo.min.svg\";\n\n  /**\n   * 背景に画像でなく文字を使う場合の、背景のフォントサイズ\n   */\n  protected fontSize = 42;\n\n  /**\n   * スプライトが描かれるキャンバスの幅\n   */\n  protected spriteCanvasWidth = 250;\n\n  /**\n   * スプライトが描かれるキャンバスの高さ\n   */\n  protected spriteCanvasHeight = 100;\n\n  /**\n   * スプライトの一行あたりの文字数\n   */\n  protected spriteCharsPerLine = 8;\n\n  /**\n   * スプライトでの一文字あたりの幅のピクセル数\n   */\n  protected spritePixelsPerDimension = 256;\n\n  /**\n   * 一文字ごとに浮遊する文字たち。最終的に背景の輪郭を構成する。\n   */\n  protected spriteString: string;\n\n  /**\n   * 浮遊する文字たちのフォント\n   */\n  protected spriteFont: googleFontNames = useStore.getState().fontName;\n\n  constructor(words: string) {\n    this.spriteString = words;\n    this.init();\n  }\n\n  private init = async () => {\n    const texture = this.createSprite();\n    this.particlesList = this.createLetterParticle(texture);\n    // 背景となる絵や文字をつくり、その形にあわせて文字を浮遊させる\n    const canvas = await this.createCanvasForSilhouette();\n    this.createMovingLetters(canvas);\n  }\n\n  public changeFont = (font: googleFontNames) => {\n    this.spriteFont = font;\n    this.particlesList = [];\n    this.movingParticles = new THREE.Object3D();\n    this.init();\n  }\n\n  /**\n   * 絵の部品となる文字たちが集まったシートを作る\n   */\n  private createSprite = () => {\n    const canvas = document.createElement(\"canvas\");\n    canvas.setAttribute(\"width\", `${this.spritePixelsPerDimension * this.spriteCharsPerLine}px`);\n    canvas.setAttribute(\"height\", `${this.spritePixelsPerDimension * this.spriteCharsPerLine}px`);\n\n    const context = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n    context.fillStyle = \"white\";\n    context.font = `200px ${this.spriteFont}`;\n    context.textAlign = \"center\";\n    context.textBaseline = \"middle\";\n\n    const len = this.spriteCharsPerLine * this.spriteCharsPerLine;\n    for (let i = 0; i < len; i++) {\n      const x = this.spritePixelsPerDimension * (i % this.spriteCharsPerLine) + this.spritePixelsPerDimension / 2;\n      const y = this.spritePixelsPerDimension * Math.floor(i / this.spriteCharsPerLine) + this.spritePixelsPerDimension / 2;\n      context.fillText(this.spriteString[i], x, y);\n    }\n\n    return new THREE.CanvasTexture(canvas);\n  };\n\n  /**\n   * スプライトの中でジオメトリをずらす\n   */\n  private getUvRandomizedGeometry = () => {\n    // 一文字分のマス目の幅(と高さ)。テクスチャの座標は 0.0 ～ 1.0\n    const unit = 1 / this.spriteCharsPerLine;\n    // 何文字分ずらすか\n    const offsetX = Math.floor(this.spriteCharsPerLine * Math.random());\n    const offsetY = Math.floor(this.spriteCharsPerLine * Math.random());\n\n    const geometry = new THREE.PlaneBufferGeometry(40, 40);\n    const uvAttribute = geometry.getAttribute(\"uv\") as THREE.BufferAttribute;\n    const uv = new THREE.Vector2();\n\n    for (let i = 0; i < uvAttribute.count; i++) {\n      const vector2 = uv.fromBufferAttribute(uvAttribute, i); // pseudo code: vector2 = uvAttribute[i]\n      uvAttribute.setXY(i, unit * (vector2.x + offsetX), unit * (vector2.y + offsetY)); // pseudo code: uvAttribute[i] = (x, y)\n    }\n\n    return geometry;\n  }\n\n  /**\n   * 浮遊する文字たちの一つ一つをパーティクルにする\n   */\n  private createLetterParticle = (texture: THREE.Texture) => {\n    const particleList: THREE.Mesh[] = [];\n    for (let i = 0; i < this.spriteCanvasWidth; i++) {\n      for (let j = 0; j < this.spriteCanvasHeight; j++) {\n        const geometry = this.getUvRandomizedGeometry();\n\n        const material = new THREE.MeshStandardMaterial({\n          color: 0xffffff,\n          map: texture,\n          transparent: true,\n          side: THREE.DoubleSide,\n        });\n\n        material.blending = THREE.AdditiveBlending;\n\n        const word = new THREE.Mesh(geometry, material);\n        particleList.push(word);\n      }\n    }\n    return particleList as THREE.Mesh<THREE.PlaneBufferGeometry, THREE.MeshLambertMaterial>[];\n  };\n\n  private loadImage = (src: string): Promise<HTMLImageElement> => new Promise((resolve) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.src = src;\n  });\n\n  /**\n   * 輪郭となる文字列が書かれたキャンバスを作る。文字列の代わりに画像のURLが指定された場合はそれを読み込んだ上で返す。\n   */\n  private createCanvasForSilhouette = async (): Promise<HTMLCanvasElement> => {\n    const label = this.silhouette;\n    const canvas = document.createElement(\"canvas\");\n    canvas.setAttribute(\"width\", `${this.spriteCanvasWidth}px`);\n    canvas.setAttribute(\"height\", `${this.spriteCanvasHeight}px`);\n    const context = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n\n    if (/\\.(png|jpg|webp|bmp|gif|svg)$/.test(label)) {\n      const res = await this.loadImage(label);\n      console.info(`Image loaded. width: ${res.width}, height: ${res.height}`);\n      context.drawImage(res, 0, 0);\n    } else {\n      context.fillStyle = \"white\";\n      context.font = `${this.fontSize}px ${this.spriteFont}`;\n      context.textAlign = \"center\";\n      context.textBaseline = \"top\";\n      context.fillText(label, this.spriteCanvasWidth / 2, 0);\n    }\n\n    return canvas;\n  }\n\n  /**\n   * 一文字ごとの移動を作成する\n   */\n  private createMovingLetters = (canvas: HTMLCanvasElement) => {\n    const pathFrom = () => ({\n      x: 2000 * (Math.random() - 0.5) - 500,\n      y: 1000 * (Math.random() - 0.5),\n      z: 10_000,\n    });\n\n    const pathTo = (horizontalPos: number, verticalPos: number) => ({\n      x: (horizontalPos - canvas.width / 2) * 30,\n      y: (canvas.height / 2 - verticalPos) * 30,\n      z: 0,\n    });\n\n    const setStateOnParticle = (particle: THREE.Mesh<THREE.PlaneBufferGeometry, THREE.MeshLambertMaterial>, from: { x: number; y: number; z: number }) => {\n      const item = particle;\n      item.position.x = from.x;\n      item.position.y = from.y;\n      item.position.z = from.z;\n      item.rotation.z = 10 * Math.PI * (Math.random() - 0.5);\n      return item;\n    };\n\n    const setTimeLine = (\n      particle: THREE.Mesh<THREE.PlaneBufferGeometry, THREE.MeshLambertMaterial>,\n      delay: number,\n      from: { x: number; y: number; z: number },\n      to: { x: number; y: number; z: number }\n    ) => {\n      gsap.timeline()\n        .set(particle, { visible: true }, delay)\n        .to(particle.rotation, { z: 0, ease: Cubic.easeInOut, duration: 6.0, }, delay)\n        .to(particle.position, {\n          delay: delay,\n          ease: Expo.easeInOut,\n          duration: 7.0,\n          motionPath: {\n            path: [\n              from,\n              {\n                x: (to.x) / 2 + 300,\n                y: (from.y + to.y) / 2 + 500 * Math.random(),\n                z: (from.z + to.z) / 2,\n              },\n              to,\n            ],\n          },\n        },\n        0);\n    };\n\n    this.particlesList.forEach((item) => {\n      item.visible = false;\n      item.material.blending = THREE.AdditiveBlending;\n    });\n\n    const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n    const pixcelColors = ctx.getImageData(0, 0, this.spriteCanvasWidth, this.spriteCanvasHeight).data;\n    let index = -1;\n    for (let hori = 0; hori < this.spriteCanvasWidth; hori++) {\n      for (let vert = 0; vert < this.spriteCanvasHeight; vert++) {\n        // 透過していたら処理を打ち切る\n        if (pixcelColors[(hori + vert * this.spriteCanvasWidth) * 4 + 3] === 0) continue;\n\n        index += 1;\n        const from = pathFrom();\n        const to = pathTo(hori, vert);\n        const delay = Cubic.easeInOut(index / 1600) * 3.0 + 1.5 * Math.random();\n        const particle = setStateOnParticle(this.particlesList[index], from);\n        this.movingParticles.add(particle);\n        setTimeLine(particle, delay, from, to);\n      }\n    }\n  }\n}\n\nexport { LetterPainter };\n","import React from \"react\";\nimport * as THREE from \"three\";\nimport TextSprite from \"@seregpie/three.text-sprite\";\nimport { GLTFLoader, OrbitControls } from \"three-stdlib\";\nimport Stats from \"three/examples/jsm/libs/stats.module\";\nimport gsap from \"gsap\";\nimport { MmdModelName } from \"../@types/types\";\nimport { loadFont, guiPanelForMorphs } from \"./Utils\";\nimport { useStore } from \"./Store\";\nimport { MMD } from \"./MMD\";\nimport { LetterPainter } from \"./LetterPainter\";\nimport { TextAlive } from \"./TextAlive\";\nimport { ThreeBase } from \"./ThreeBase\";\nimport { Util } from \"konva/lib/Util\";\n\n// eslint-disable-next-line no-var\ndeclare var Ammo: any;\n\nexport class Stage extends ThreeBase {\n  /**\n   * currently selected font for rendering sprite particles\n   */\n  font?: string;\n  /**\n   * the lyric text of currently playing song\n   */\n  lyricText?: string;\n  lyricsChars: Map<number, TextSprite> = new Map<number, TextSprite>();\n\n  refTextAlive?: React.MutableRefObject<TextAlive>;\n\n  // controls?: OrbitControls;\n  timer: THREE.Clock;\n  stats?: Stats;\n\n  _previousBpm = 0;\n  effectRank: 0 | 1 | 2 | 3 | 4 = 0;\n\n  constructor(canvas: HTMLCanvasElement, stats?: Stats) {\n    super(canvas, \"Perspective\");\n    if (stats) this.stats = stats;\n    this.timer = new THREE.Clock();\n    const floor = new THREE.PolarGridHelper(500);\n    this.scene.add(floor);\n    this.camera.position.y = 5;\n    // this.controls = this.createController();\n    useStore.subscribe(\n      (effectRank) => {\n        console.info(`new effect rank: ${effectRank}`);\n        this.effectRank = effectRank as 0 | 1 | 2 | 3 | 4;\n      },\n      (state) => state.effectRank\n    );\n\n    this.refTextAlive = useStore.getState().refTextAlive;\n    this.init();\n  }\n\n  /**\n   * Starts app with loading physics engine.\n   * I think some explanations needed about this queer initializing for a physics engine.\n   * Here is the reason why ( cited from https://www.npmjs.com/package/ammojs-typed ):\n   *\n   * **********\n   * Then import ammo like this\n   * ```javascript\n   * import Ammo from 'ammojs-typed'\n   * ```\n   *\n   * This works but be cautious here. The default import gives you the bootstrap function.\n   * After bootstrapping the api is not available through the Ammo symbol by default.\n   *\n   * ```javascript\n   * Ammo().then(api => {\n   *   const v1 = new api.btVector3(1, 2, 3)\n   *   const v2 = new Ammo.btVector3(1, 2, 3) // <-- runtime error here\n   * })\n   * ```\n   *\n   * You can work around that by booting like this\n   * ```javascript\n   * Ammo(Ammo).then(() => { const v2 = new Ammo.btVector3(1, 2, 3) }) // <-- works\n   * ```\n   */\n  init = async () => {\n    await Ammo(Ammo);\n\n    this.scene.add(await this.#addAudience());\n    this.#animate(0);\n  }\n\n  #animate = (time: number) => {\n    const deltaSeconds = this.timer.getDelta();\n\n    setTimeout(() => {\n      requestAnimationFrame((time) => this.#animate(time));\n    }, 1000 / 60 / this.frameRateWeight);\n\n    const { selectedModelNames } = useStore.getState();\n    this.#withTextAlive(selectedModelNames);\n\n    for (const modelName of selectedModelNames) {\n      time % 1000 <= 40 && MMD.blink(modelName, 0);\n      time % 1000 >= 500 && time % 1000 <= 550 && MMD.blink(modelName, 1);\n      Math.random() > 0.95 && MMD.mouthFlap(modelName, Math.random());\n    }\n\n    this.camera.lookAt(new THREE.Vector3(0, 6, 0));\n    // this.controls?.update();\n    this.stats?.update();\n\n    (this.effect ?? this.renderer).render(this.scene, this.camera);\n    MMD.helper.update(deltaSeconds);\n  }\n\n  letterPainter = async () => {\n    await loadFont(useStore.getState().fontName);\n    return new LetterPainter(this.lyricText as string).movingParticles;\n  }\n\n  addModel = async (modelName: MmdModelName) => {\n    const model = await MMD.loadMmdModel(modelName);\n    await MMD.loadMotion(modelName, model);\n\n    // guiPanelForPoses(modelName);\n    guiPanelForMorphs(modelName);\n\n    model.visible = false;\n    this.scene.add(model);\n    const sampled = MMD.createSampler(model, modelName);\n    this.scene.add(sampled);\n    gsap\n      .timeline()\n      .to(sampled.material.uniforms.progress, {\n        value: 1.0,\n        duration: 2,\n        onComplete: () => {\n          sampled.visible = false;\n          model.visible = true;\n        },\n      });\n  }\n\n  removeModel = async (modelName: MmdModelName) => {\n    this.scene.getObjectByName(modelName)?.removeFromParent();\n  }\n\n  createController = () => {\n    const controls = new OrbitControls(this.camera, document.querySelector(\"article\") as HTMLElement);\n    controls.rotateSpeed = 3.0;\n    return controls;\n  }\n\n  #addAudience = async () => {\n    const gpuTier = useStore.getState().gpuTier;\n    const count = gpuTier > 2 ? 700 : gpuTier === 2 ? 300 : 150;\n    const originVector = new THREE.Vector3(0, 0, 0);\n    // forbid enter of the audience into the center of the stage\n    const limitRadius = 20;\n    const dummyColor = new THREE.Color();\n\n    const getPosition = (): THREE.Vector3 => {\n      const theta = Math.random() * 2 * Math.PI;\n      const radius = Math.random() * 400;\n      const pos = new THREE.Vector3(Math.sin(theta) * radius, 0, Math.cos(theta) * radius);\n      return (pos.lengthSq() >= limitRadius * limitRadius) ? pos : getPosition();\n    };\n\n    const gltf = await new GLTFLoader().loadAsync(\"assets/models/BlockMan/BlockMan.glb\");\n    const { geometry, material } = gltf.scene.getObjectByName(\"Proxy\") as THREE.Mesh;\n    const _geometry = geometry.clone();\n    _geometry.scale(0.1, 0.1, 0.1);\n\n    const blockman = new THREE.InstancedMesh(_geometry, material, count);\n\n    for (let i = 0; i < count; i++) {\n      // make the random color a little brighter\n      const color = Math.min(parseInt(Util.getRandomColor().slice(1), 16) * 1.2, 0xffffff);\n      dummyColor.set(color);\n      blockman.setColorAt(i, dummyColor);\n\n      const newPosition = getPosition();\n      blockman.setMatrixAt(i, new THREE.Matrix4().setPosition(newPosition).lookAt(originVector, newPosition, blockman.up));\n    }\n\n    blockman.instanceMatrix.needsUpdate = true;\n    return blockman;\n  }\n\n  #withTextAlive = (selectedModelNames: MmdModelName[]) => {\n    const bpmElm = document.getElementById(\"BPM\");\n    const letterElm = document.getElementById(\"Letter\");\n    const furiganaElm = document.getElementById(\"Furigana\");\n    if (!bpmElm || !letterElm || !furiganaElm) return;\n\n    const currentBpm = this.refTextAlive?.current.currentBpm ?? 0;\n    if (currentBpm !== this._previousBpm) {\n      this._previousBpm = currentBpm;\n    }\n    for (const modelName of selectedModelNames) {\n      const motion = MMD.findMotion(modelName, \"スクワット\");\n      if (!motion) continue;\n      motion.timeScale = currentBpm / 120;\n    }\n    bpmElm.textContent = String(this.refTextAlive?.current.currentBpm ?? 0);\n    letterElm.textContent = this.refTextAlive?.current.currentLetter?.letter ?? \"\";\n    furiganaElm.textContent = this.refTextAlive?.current.currentFurigana ?? \"\";\n  }\n\n  onModelUpdated = (modelsAfter: MmdModelName[], modelsBefore: MmdModelName[]) => {\n    const added = (modelsAfter as MmdModelName[]).filter((item) => !(modelsBefore as MmdModelName[]).includes(item));\n    const removed = (modelsBefore as MmdModelName[]).filter((item) => !(modelsAfter as MmdModelName[]).includes(item));\n    added.forEach((model) => this.addModel(model));\n    removed.forEach((model) => this.removeModel(model));\n  };\n\n  // #createTextSprite = (text: string, fontName: googleFontNames = useStore.getState().fontName) => {\n  //   return new TextSprite({\n  //     color: \"rgb(87,161,150)\",\n  //     fontFamily: fontName,\n  //     fontSize: 6,\n  //     // strokeColor: \"rgba(0, 0, 0, 1)\",\n  //     // strokeWidth: 0.007,\n  //     text: text,\n  //   });\n  // }\n\n  // #renderSprite = () => {\n  //   this.lyricsChars.forEach((sprite) => {\n  //     sprite.position.set(Math.random() * 200 - 100, Math.random() * 200 - 80, Math.random() * 200);\n  //     this.scene.add(sprite);\n  //   });\n  // }\n}\n","import * as THREE from \"three\";\nimport { OutlineEffect } from \"three-stdlib\";\nimport { useStore } from \"./Store\";\n\n/**\n * THREE.js のプロジェクトのテンプレート。\n */\nexport class ThreeBase {\n  canvas: HTMLCanvasElement;\n  scene: THREE.Scene;\n  camera: THREE.PerspectiveCamera | THREE.OrthographicCamera;\n  renderer: THREE.WebGLRenderer;\n  effect?: OutlineEffect;\n  frameRateWeight: 1 | 2 | 3 = 1;\n  frames = 0;\n\n  constructor(canvas: HTMLCanvasElement, cameraType: \"Perspective\" | \"Orthographic\") {\n    this.canvas = canvas;\n    this.renderer = this.#createRenderer();\n    if (cameraType === \"Perspective\") {\n      this.effect = new OutlineEffect(this.renderer);\n    }\n    this.camera = this.#createCamera(cameraType);\n    this.scene = this.#createScene();\n    this.scene.add(this.#createAmbientLight(\"#666666\"));\n    this.scene.add(this.#createDirectionalLight(\"#887766\"));\n    this.frameRateWeight = this.getFrameRateWeight();\n\n    window.addEventListener(\"resize\", this.#onWindowResize);\n  }\n\n  #createRenderer = (): THREE.WebGLRenderer => {\n    const renderer = new THREE.WebGLRenderer({ canvas: this.canvas, alpha: true, antialias: true, });\n    // to make the background fully transparent\n    renderer.setClearColor(\"#ffffff\", 0);\n    // to reduce computation load on mobile devices\n    // renderer.setPixelRatio(1);\n    renderer.setPixelRatio(window.devicePixelRatio);\n    // fullscreen\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    return renderer;\n  }\n\n  #createScene = (): THREE.Scene => {\n    const scene = new THREE.Scene();\n    scene.background = null;\n    return scene;\n  }\n\n  #createCamera = (cameraType: \"Perspective\" | \"Orthographic\") => {\n    // for the canvas element for hand tracking\n    if (cameraType === \"Orthographic\") {\n      // arguments: left, right, top, bottom, near, far\n      const camera = new THREE.OrthographicCamera(0, 100, 100, 0, 0.1, 10_000);\n      camera.position.set(0, 0, 20); // カメラを遠ざける\n      return camera;\n    }\n    // for the canvas for main rendering\n    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100_000);\n    // arguments: field of view, aspect ratio, near, far\n    camera.position.set(0, 0, 20);// カメラを遠ざける\n    return camera;\n  }\n\n  #createAmbientLight = (color: THREE.Color | string | number) => new THREE.AmbientLight(color)\n\n  #createDirectionalLight = (color: THREE.Color | string | number) => {\n    const directionalLight = new THREE.DirectionalLight(color);\n    directionalLight.position.set(-1, 1, 1).normalize();\n    return directionalLight;\n  }\n\n  #onWindowResize = () => {\n    if (this.camera instanceof THREE.PerspectiveCamera) {\n      this.camera.aspect = window.innerWidth / window.innerHeight;\n      this.camera.updateProjectionMatrix();\n    }\n    (this.effect ?? this.renderer).setSize(window.innerWidth, window.innerHeight);\n  }\n\n  getFrameRateWeight = () => {\n    const gpuTier = useStore.getState().gpuTier;\n    if (useStore.getState().isMobileGpu) {\n      if (gpuTier > 2) return 1;\n      if (gpuTier === 2) return 2;\n      if (gpuTier < 2) return 3;\n    }\n    if (gpuTier > 2) return 1;\n    if (gpuTier === 2) return 2;\n    if (gpuTier < 2) return 3;\n    return 1;\n  }\n}\n","import React, { useEffect } from \"react\";\n/** @jsx jsx */\n// noinspection ES6UnusedImports\nimport { css, jsx } from \"@emotion/react\";\n\ninterface PropType {\n  id: string;\n  zIndex: number;\n  css?: any;\n}\n\nexport const CanvasBase = React.forwardRef(({ id, zIndex }: PropType, ref) => {\n  function resizeCanvas(canvasElement: HTMLCanvasElement, ratio: number) {\n    canvasElement.width = window.innerWidth;\n    canvasElement.height = window.innerWidth * ratio;\n  }\n\n  useEffect(() => {\n    // @ts-ignore\n    const canvas = ref.current as HTMLCanvasElement;\n\n    const ratio = window.innerHeight / window.innerWidth;\n    resizeCanvas(canvas, ratio);\n    window.addEventListener(\"resize\", () => resizeCanvas(canvas, ratio));\n  }, []);\n\n  return (\n    <canvas\n      id={id}\n      // @ts-ignore\n      ref={ref}\n      css={css`\n        display: block;\n        z-index: ${zIndex};\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100vw;\n        max-width: 100vw;\n        height: 100vh;\n        max-height: 100vh;\n      `}\n    />\n  );\n});\n","import React, { useRef, useEffect, useState } from \"react\";\n/** @jsx jsx */\n// noinspection ES6UnusedImports\nimport { css, jsx } from \"@emotion/react\";\nimport { Stage as KonvaStage } from \"konva/lib/Stage\";\nimport { Stage, Layer, Text } from \"react-konva/es/ReactKonvaCore\";\nimport \"konva/lib/shapes/Text\";\nimport { Stage as CanvasStage } from \"../components/Stage\";\nimport { CanvasBase } from \"./CanvasBase\";\nimport { googleFontNames } from \"../@types/types\";\nimport { ExtendedChar } from \"../components/TextAlive\";\nimport { useStore } from \"../components/Store\";\nimport { guiMmdModels, statsStage, guiFonts, loadFont } from \"../components/Utils\";\n\ninterface PropType {\n  zIndex: number;\n}\n\ninterface PropTypeText {\n  text: string;\n  id: number;\n}\n\nconst MyText = ({ text, id }: PropTypeText) => {\n  return (\n    <Text\n      text={text}\n      fontSize={70}\n      fontFamily={useStore.getState().fontName}\n      name={`Text-${id}`}\n      x={window.innerWidth * 1.2}\n      y={window.innerHeight * 1.2}\n      fill={\"#151515\"}\n      stroke={\"#f0f0f0\"}\n      strokeWidth={10}\n      fillAfterStrokeEnabled={true}\n    />\n  );\n};\n\n\nconst onLyricsLoaded = (setTextSPrites: (sprites: JSX.Element[]) => void, lyricsChars: Map<number, ExtendedChar> | undefined) => {\n  if (!lyricsChars) {\n    // 曲が変わって歌詞が破棄されたとき\n    setTextSPrites([]);\n    return;\n  }\n\n  // 歌詞が読み込まれたとき\n  const lyrics = [...lyricsChars.values()]\n    .filter(({ letter }) => letter !== \"\")\n    .map((char) => (\n      <MyText text={char.letter} id={char.index} key={char.index} />\n    ));\n\n  setTextSPrites(lyrics);\n};\n\nconst onFontChanged = async (setTextSPrites: (sprites: JSX.Element[]) => void, fontName: googleFontNames) => {\n  await loadFont(fontName);\n  // スプライトを破棄して\n  onLyricsLoaded(setTextSPrites, undefined);\n  // スプライトを再生成する\n  onLyricsLoaded(setTextSPrites, useStore.getState().lyricChars);\n};\n\n\nexport default ({ zIndex }: PropType) => {\n  const [textSPrites, setTextSPrites] = useState<JSX.Element[]>([]);\n  const refCanvasStage = useRef<HTMLCanvasElement>(null);\n  const refKonvaStage = useRef<KonvaStage>(null);\n\n\n  useEffect(() => {\n    const canvasElement = refCanvasStage.current as HTMLCanvasElement;\n    const stage = new CanvasStage(canvasElement, statsStage);\n\n    useStore.setState({\n      instanceStage: stage,\n      refKonvaLayer: refKonvaStage.current!.getLayers()[0],\n    });\n\n    guiFonts();\n    guiMmdModels();\n\n    setTimeout(() => (\n      useStore.getState().selectedModelNames.forEach((modelName) => stage.addModel(modelName))\n    ), 500);\n\n    /** Event listner. When \"lyricsChars\" in Store.ts updates, \"onLyricsLoaded\" is called. */\n    useStore.subscribe(\n      (lyricsChars) => onLyricsLoaded((sprites) => setTextSPrites(sprites), lyricsChars as Map<number, ExtendedChar>),\n      (state) => state.lyricChars\n    );\n\n    /** Event listner. When \"fontName\" in Store.ts updates, \"onFontChanged\" is called. */\n    useStore.subscribe(\n      (fontName) => onFontChanged((sprites) => setTextSPrites(sprites), fontName as googleFontNames),\n      (state) => state.fontName\n    );\n\n  }, []);\n\n\n  return (\n    <>\n      <CanvasBase\n        id=\"canvas-stage\"\n        ref={refCanvasStage}\n        zIndex={zIndex}\n      />\n      <Stage\n        ref={refKonvaStage}\n        width={window.innerWidth}\n        height={window.innerHeight}\n        css={css`\n          display: block;\n          z-index: ${zIndex};\n          position: fixed;\n          top: 0;\n          left: 0;\n          width: 100vw;\n          max-width: 100vw;\n          height: 100vh;\n          max-height: 100vh;\n        `}\n      >\n        <Layer>\n          {textSPrites}\n        </Layer>\n      </Stage>\n    </>\n  );\n};\n"],"names":["gsap","LetterPainter","constructor","words","movingParticles","particlesList","silhouette","fontSize","spriteCanvasWidth","spriteCanvasHeight","spriteCharsPerLine","spritePixelsPerDimension","spriteFont","fontName","init","async","texture","this","createSprite","createLetterParticle","canvas","createCanvasForSilhouette","createMovingLetters","changeFont","font","document","createElement","setAttribute","context","getContext","fillStyle","textAlign","textBaseline","len","i","x","y","Math","floor","fillText","spriteString","getUvRandomizedGeometry","unit","offsetX","random","offsetY","geometry","uvAttribute","getAttribute","uv","count","vector2","fromBufferAttribute","setXY","particleList","j","material","color","map","transparent","side","blending","word","push","loadImage","src","Promise","resolve","img","Image","onload","label","test","res","console","info","width","height","drawImage","setStateOnParticle","particle","from","item","position","z","rotation","PI","setTimeLine","delay","to","set","visible","ease","duration","motionPath","path","forEach","pixcelColors","getImageData","data","index","hori","vert","verticalPos","add","Stage","cameraType","frameRateWeight","frames","renderer","alpha","antialias","setClearColor","setPixelRatio","window","devicePixelRatio","setSize","innerWidth","innerHeight","scene","background","camera","directionalLight","normalize","aspect","updateProjectionMatrix","effect","getFrameRateWeight","gpuTier","isMobileGpu","OutlineEffect","addEventListener","stats","super","lyricsChars","Map","_previousBpm","effectRank","Ammo","time","deltaSeconds","timer","getDelta","setTimeout","requestAnimationFrame","selectedModelNames","modelName","MMD","M","lookAt","update","render","letterPainter","lyricText","addModel","model","sampled","uniforms","progress","value","onComplete","removeModel","getObjectByName","removeFromParent","createController","controls","OrbitControls","querySelector","rotateSpeed","originVector","dummyColor","getPosition","theta","radius","pos","sin","cos","lengthSq","limitRadius","gltf","GLTFLoader","loadAsync","_geometry","clone","scale","blockman","min","parseInt","Util","slice","setColorAt","newPosition","setMatrixAt","setPosition","up","instanceMatrix","needsUpdate","bpmElm","getElementById","letterElm","furiganaElm","currentBpm","refTextAlive","current","motion","timeScale","textContent","String","currentLetter","letter","currentFurigana","onModelUpdated","modelsAfter","modelsBefore","added","filter","includes","removed","state","CanvasBase","id","zIndex","ref","resizeCanvas","canvasElement","ratio","useEffect","css","MyText","text","fontFamily","name","fill","stroke","strokeWidth","fillAfterStrokeEnabled","onLyricsLoaded","setTextSPrites","values","char","textSPrites","useState","refCanvasStage","useRef","refKonvaStage","stage","instanceStage","refKonvaLayer","getLayers","sprites","lyricChars","undefined","onFontChanged"],"sourceRoot":""}